(datatype Literal)
(datatype Expr)
(datatype Operand)
(datatype Body)

(sort VecOperand (Vec Operand))
(datatype VecOperandWrapper
  (VO VecOperand))
(sort VecVecOperand (Vec VecOperandWrapper))

;; Type
(datatype Type
    (IntT)
    (BoolT)
    (FloatT)
    (CharT)
    (PointerT Type))

;; Literal
(function Num (i64) Literal)
(function Float (f64) Literal)
(function Char (String) Literal)

;; Expr
(datatype ConstOps (const))
(function Const (ConstOps Type Literal) Expr)
(function Call (String VecOperand) Expr)
(function add (Operand Operand) Expr)
(function sub (Operand Operand) Expr)
(function mul (Operand Operand) Expr)
(function div (Operand Operand) Expr)
(function eq (Operand Operand) Expr)
(function lt (Operand Operand) Expr)
(function gt (Operand Operand) Expr)
(function le (Operand Operand) Expr)
(function ge (Operand Operand) Expr)
(function not (Operand Operand) Expr)
(function and (Operand Operand) Expr)
(function or (Operand Operand) Expr)

;; Operand
(function Arg (i64) Operand)
(function Node (Body) Operand)
(function Project (i64 Body) Operand)

;; Body
(function PureOp (Expr) Body)
(function Gamma (Operand VecOperand VecVecOperand) Body) ;; branching
(function Theta (Operand VecOperand VecOperand) Body) ;; loop


;; procedure f(n):
;;   i = 0
;;   while i < n
;;     ans += i * 5
;;     i += 1
;;   return ans

;; ;; inputs: [n]
;; (Project 1
;;     (Theta 
;;         (Lt (Arg 1) (Arg 2)) ;; pred
;;         (vec-of ;; inputs
;;             (Node (PureOp (Const 0))) ;; accumulator
;;             (Node (PureOp (Const 0))) ;; loop var
;;             (Arg 0) ;; n
;;             )
;;         (vec-of ;; outputs
;;             (Node (PureOp (Add (Arg 0) 
;;                 (Node (PureOp (Mul 
;;                     (Arg 1)
;;                     (Node (PureOp (Const 5)))))))))
;;             (Node (PureOp (Add (Arg 1) (Node (PureOp (Const 1))))))
;;             (Arg 2)
;;         ))
;; )


;; program:
;; len = < known positive >
;; for (i = 0; i < n; i++) {
;;     if (0 <= i && i < len) {
;;       do_something();
;;     } else {
;;       throw_out_of_bounds();
;;     }
;; }
;;
;; =>
;; len = < known positive >
;; limit = smin(n, len)
;; // no first segment
;; for (i = 0; i < limit; i++) {
;;   if (0 <= i && i < len) { // this check is fully redundant
;;     do_something();
;;   } else {
;;     throw_out_of_bounds();
;;   }
;; }
;; for (i = limit; i < n; i++) {
;;   if (0 <= i && i < len) {
;;     do_something();
;;   } else {
;;     throw_out_of_bounds();
;;   }
;; }
;;
;;
;; we recoginize:
;; - gamma node with signed comparison, inner theta node with the same signed comparison
;;   as its latch (this could possibly optional with smart analysis?)
;; - theta node with traditional signed comparison, single step iteration, one child which is a
;; - gamma node with comparison of induction variable to well known constant limit (will be optimized out)
;; we rewrite to:
;; - two theta nodes with identical bodies
;; - one theta node goes from 0 to smin(n, len), the other from the last iter step to n
;;

(rewrite
    (Gamma
        (Theta)))
